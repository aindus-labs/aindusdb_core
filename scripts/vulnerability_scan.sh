#!/bin/bash
# ðŸ” vulnerability_scan.sh - Scanner de vulnÃ©rabilitÃ©s automatisÃ©
# Usage: ./vulnerability_scan.sh [output_format]

OUTPUT_FORMAT=${1:-"json"}  # json, html, pdf
REPORT_DIR="security_reports"
TIMESTAMP=$(date +"%Y%m%d_%H%M%S")
REPORT_FILE="$REPORT_DIR/vulnerability_scan_$TIMESTAMP.$OUTPUT_FORMAT"

echo "ðŸ” SCANNER DE VULNÃ‰RABILITÃ‰S - AindusDB Core"
echo "=========================================="
echo "Format sortie : $OUTPUT_FORMAT"
echo "Rapport : $REPORT_FILE"
echo ""

# CrÃ©er le rÃ©pertoire des rapports
mkdir -p $REPORT_DIR

# VÃ©rifier les outils requis
check_tools() {
    echo "ðŸ“¦ VÃ©rification des outils..."
    
    # Python
    if ! command -v python3 &> /dev/null && ! command -v py &> /dev/null; then
        echo "âŒ Python non trouvÃ©"
        exit 1
    fi
    
    # pip
    if ! command -v pip &> /dev/null && ! command -v pip3 &> /dev/null; then
        echo "âŒ pip non trouvÃ©"
        exit 1
    fi
    
    echo "âœ… Outils requis disponibles"
}

# Installer les dÃ©pendances de sÃ©curitÃ©
install_security_tools() {
    echo ""
    echo "ðŸ“¦ Installation des outils de sÃ©curitÃ©..."
    
    # Safety (Python)
    pip install safety bandit semgrep
    
    # npm si disponible pour Node.js
    if command -v npm &> /dev/null; then
        npm install -g audit-ci
    fi
    
    echo "âœ… Outils de sÃ©curitÃ© installÃ©s"
}

# Scanner les dÃ©pendances Python
scan_python_deps() {
    echo ""
    echo "ðŸ Scan des dÃ©pendances Python..."
    
    # Safety scan
    echo "  â€¢ Safety (vulnÃ©rabilitÃ©s connues)..."
    safety check --json --output safety_report.json 2>/dev/null || safety check --output safety_report.txt
    
    # Bandit (SAST)
    echo "  â€¢ Bandit (analyse statique)..."
    bandit -r app/ -f json -o bandit_report.json 2>/dev/null || bandit -r app/ -o bandit_report.txt
    
    # Semgrep (SAST avancÃ©)
    echo "  â€¢ Semgrep (rÃ¨gles custom)..."
    semgrep --config=auto --json --output=semgrep_report.json app/ 2>/dev/null || semgrep --config=auto app/ > semgrep_report.txt
}

# Scanner les secrets
scan_secrets() {
    echo ""
    echo "ðŸ”‘ Scan des secrets et credentials..."
    
    # TruffleHog (si disponible)
    if command -v trufflehog &> /dev/null; then
        trufflehog filesystem . --json --output=trufflehog_report.json
    else
        # Scan simple avec grep
        echo "  â€¢ Scan patterns secrets..."
        grep -r -i -E "(password|secret|key|token)\s*=\s*['\"][^'\"]{8,}['\"]" --include="*.py" --include="*.yaml" --include="*.yml" --include="*.json" --include="*.env*" . > secrets_found.txt || true
    fi
    
    # Gitleaks (si disponible)
    if command -v gitleaks &> /dev/null; then
        gitleaks detect --source . --report-format json --report-path=gitleaks_report.json
    fi
}

# Scanner la configuration
scan_config() {
    echo ""
    echo "âš™ï¸  Scan de la configuration..."
    
    # VÃ©rifier .env
    if [ -f ".env" ]; then
        echo "  â€¢ Analyse .env..."
        grep -E "^(DEBUG|ENVIRONMENT|CORS_ORIGINS|SSL_ENABLED)" .env > config_analysis.txt
    fi
    
    # VÃ©rifier Docker
    if [ -f "docker-compose.yml" ]; then
        echo "  â€¢ Analyse Docker..."
        grep -E "^(image|ports|environment)" docker-compose.yml > docker_analysis.txt
    fi
    
    # VÃ©rifier requirements
    if [ -f "requirements.txt" ]; then
        echo "  â€¢ Analyse requirements..."
        wc -l requirements.txt > req_count.txt
    fi
}

# Scanner le code source
scan_source_code() {
    echo ""
    echo "ðŸ“ Scan du code source..."
    
    # Patterns dangereux
    echo "  â€¢ Recherche patterns dangereux..."
    grep -r -n "eval(" --include="*.py" app/ > dangerous_patterns.txt 2>/dev/null || echo "Aucun eval() trouvÃ©" > dangerous_patterns.txt
    grep -r -n "exec(" --include="*.py" app/ >> dangerous_patterns.txt 2>/dev/null || true
    grep -r -n "subprocess.call" --include="*.py" app/ >> dangerous_patterns.txt 2>/dev/null || true
    grep -r -n "os.system" --include="*.py" app/ >> dangerous_patterns.txt 2>/dev/null || true
    
    # VÃ©rifications SQLi
    echo "  â€¢ VÃ©rifications injection SQL..."
    grep -r -n -E "(f\".*{.*}.*SELECT|\".*%s.*SELECT|'.*'\+.*SELECT)" --include="*.py" app/ > sqli_patterns.txt 2>/dev/null || echo "Aucun pattern SQLi dÃ©tectÃ©" > sqli_patterns.txt
}

# GÃ©nÃ©rer le rapport
generate_report() {
    echo ""
    echo "ðŸ“Š GÃ©nÃ©ration du rapport..."
    
    # Compter les vulnÃ©rabilitÃ©s
    SAFETY_ISSUES=$(cat safety_report.json 2>/dev/null | jq '.vulnerabilities | length' 2>/dev/null || echo "0")
    BANDIT_ISSUES=$(cat bandit_report.json 2>/dev/null | jq '.results | length' 2>/dev/null || echo "0")
    SEMGREP_ISSUES=$(cat semgrep_report.json 2>/dev/null | jq '.results | length' 2>/dev/null || echo "0")
    SECRETS_FOUND=$(cat secrets_found.txt 2>/dev/null | wc -l || echo "0")
    
    # Score de sÃ©curitÃ©
    TOTAL_ISSUES=$((SAFETY_ISSUES + BANDIT_ISSUES + SEMGREP_ISSUES + SECRETS_FOUND))
    if [ $TOTAL_ISSUES -eq 0 ]; then
        SECURITY_SCORE="10.0"
        RISK_LEVEL="FAIBLE"
        RISK_COLOR="ðŸŸ¢"
    elif [ $TOTAL_ISSUES -le 5 ]; then
        SECURITY_SCORE="8.5"
        RISK_LEVEL="MOYEN"
        RISK_COLOR="ðŸŸ¡"
    elif [ $TOTAL_ISSUES -le 15 ]; then
        SECURITY_SCORE="6.5"
        RISK_LEVEL="Ã‰LEVÃ‰"
        RISK_COLOR="ðŸŸ "
    else
        SECURITY_SCORE="4.0"
        RISK_LEVEL="CRITIQUE"
        RISK_COLOR="ðŸ”´"
    fi
    
    # CrÃ©er le rapport JSON
    cat > $REPORT_FILE << EOF
{
  "metadata": {
    "scan_date": "$(date -Iseconds)",
    "scanner": "AindusDB Vulnerability Scanner v1.0",
    "target": "AindusDB Core",
    "scan_type": "Automated Security Scan"
  },
  "summary": {
    "total_vulnerabilities": $TOTAL_ISSUES,
    "security_score": $SECURITY_SCORE,
    "risk_level": "$RISK_LEVEL",
    "risk_color": "$RISK_COLOR"
  },
  "vulnerabilities": {
    "dependencies": {
      "tool": "Safety",
      "issues": $SAFETY_ISSUES,
      "report_file": "safety_report.json"
    },
    "code_analysis": {
      "tool": "Bandit",
      "issues": $BANDIT_ISSUES,
      "report_file": "bandit_report.json"
    },
    "advanced_sast": {
      "tool": "Semgrep",
      "issues": $SEMGREP_ISSUES,
      "report_file": "semgrep_report.json"
    },
    "secrets": {
      "found": $SECRETS_FOUND,
      "report_file": "secrets_found.txt"
    }
  },
  "recommendations": [
    "Corriger les vulnÃ©rabilitÃ©s de dÃ©pendances (pip install --upgrade)",
    "Revoir le code avec les issues Bandit (sÃ©curitÃ©)",
    "Analyser les rÃ©sultats Semgrep (patterns avancÃ©s)",
    "Supprimer ou sÃ©curiser les secrets trouvÃ©s"
  ],
  "next_scan": "$(date -d '+7 days' -Iseconds)"
}
EOF
    
    echo "âœ… Rapport gÃ©nÃ©rÃ© : $REPORT_FILE"
}

# Fonction principale
main() {
    check_tools
    install_security_tools
    scan_python_deps
    scan_secrets
    scan_config
    scan_source_code
    generate_report
    
    echo ""
    echo "=========================================="
    echo "ðŸ“Š RÃ‰SUMÃ‰ DU SCAN"
    echo "=========================================="
    echo "Score de sÃ©curitÃ© : $SECURITY_SCORE/10 ($RISK_LEVEL $RISK_COLOR)"
    echo "VulnÃ©rabilitÃ©s totales : $TOTAL_ISSUES"
    echo "  â€¢ DÃ©pendances : $SAFETY_ISSUES"
    echo "  â€¢ Code source : $BANDIT_ISSUES"
    echo "  â€¢ SAST avancÃ© : $SEMGREP_ISSUES"
    echo "  â€¢ Secrets : $SECRETS_FOUND"
    echo ""
    echo "ðŸ“„ Rapport dÃ©taillÃ© : $REPORT_FILE"
    echo ""
    echo "ðŸŽ¯ Actions recommandÃ©es :"
    echo "1. Consulter les rapports dÃ©taillÃ©s dans $REPORT_DIR/"
    echo "2. Prioriser les vulnÃ©rabilitÃ©s critiques"
    echo "3. Mettre Ã  jour les dÃ©pendances"
    echo "4. Supprimer les secrets exposÃ©s"
    echo ""
    echo "ðŸ”„ Prochain scan recommandÃ© : $(date -d '+7 days' +%d/%m/%Y)"
}

# ExÃ©cuter le scan
main "$@"
